/**
 * Generated by orval v8.4.2 üç∫
 * Do not edit manually.
 * Nullable OneOf Enums
 * Test case for issue
 * OpenAPI spec version: 1.0.0
 */
import axios from 'axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';

import { faker } from '@faker-js/faker';

import { HttpResponse, http } from 'msw';
import type { RequestHandlerOptions } from 'msw';

import { BlankEnum, HelloEnum, NotNullEnum } from './model';
import type {
  Item1,
  Item3,
  MixedEnumItem,
  MixedTypeEnums,
  NestedItem,
} from './model';

export const getItems = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Item1[]>> => {
  return axios.get(`/items`, options);
};

export const getItemsWithMultipleProps = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Item3[]>> => {
  return axios.get(`/items-with-multiple-props`, options);
};

export const getNestedItems = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<NestedItem[]>> => {
  return axios.get(`/nested-items`, options);
};

export const getMixedEnumItems = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MixedEnumItem[]>> => {
  return axios.get(`/mixed-enum-items`, options);
};

export const getMixedTypeEnums = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MixedTypeEnums[]>> => {
  return axios.get(`/mixed-type-enums`, options);
};

export type GetItemsResult = AxiosResponse<Item1[]>;
export type GetItemsWithMultiplePropsResult = AxiosResponse<Item3[]>;
export type GetNestedItemsResult = AxiosResponse<NestedItem[]>;
export type GetMixedEnumItemsResult = AxiosResponse<MixedEnumItem[]>;
export type GetMixedTypeEnumsResult = AxiosResponse<MixedTypeEnums[]>;

export const getGetItemsResponseMock = (): Item1[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    hello: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.helpers.arrayElement(Object.values(HelloEnum)),
        faker.helpers.arrayElement(Object.values(BlankEnum)),
        faker.helpers.arrayElement([] as const),
      ]),
      null,
    ]),
  }));

export const getGetItemsWithMultiplePropsResponseMock = (): Item3[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    hello: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.helpers.arrayElement(Object.values(HelloEnum)),
        faker.helpers.arrayElement(Object.values(BlankEnum)),
        faker.helpers.arrayElement([] as const),
      ]),
      null,
    ]),
    world: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.helpers.arrayElement([1, 2, 3] as const),
        faker.datatype.boolean(),
      ]),
      null,
    ]),
    optional: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.helpers.arrayElement(Object.values(HelloEnum)),
        faker.helpers.arrayElement(Object.values(BlankEnum)),
      ]),
      null,
    ]),
  }));

export const getGetNestedItemsResponseMock = (): NestedItem[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    nested: faker.helpers.arrayElement([
      {
        hello: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.helpers.arrayElement(Object.values(HelloEnum)),
            faker.helpers.arrayElement(Object.values(BlankEnum)),
            faker.helpers.arrayElement([] as const),
          ]),
          null,
        ]),
        world: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.helpers.arrayElement([1, 2, 3] as const),
            faker.datatype.boolean(),
          ]),
          null,
        ]),
      },
      undefined,
    ]),
  }));

export const getGetMixedEnumItemsResponseMock = (): MixedEnumItem[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    mixed: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.helpers.arrayElement(Object.values(HelloEnum)),
        faker.helpers.arrayElement(Object.values(BlankEnum)),
        faker.helpers.arrayElement(Object.values(NotNullEnum)),
      ]),
      null,
    ]),
  }));

export const getGetMixedTypeEnumsResponseMock = (): MixedTypeEnums[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    stringEnum: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.helpers.arrayElement(Object.values(HelloEnum)),
        faker.helpers.arrayElement(Object.values(BlankEnum)),
      ]),
      null,
    ]),
    numberEnum: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.helpers.arrayElement([1.5, 2.5, 3.5] as const),
        faker.helpers.arrayElement([100.1, 200.2] as const),
      ]),
      null,
    ]),
    integerEnum: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.helpers.arrayElement([10, 20, 30] as const),
        faker.helpers.arrayElement([1000, 2000] as const),
      ]),
      null,
    ]),
    booleanEnum: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.datatype.boolean(),
        faker.datatype.boolean(),
      ]),
      null,
    ]),
  }));

export const getGetItemsMockHandler = (
  overrideResponse?:
    | Item1[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<Item1[]> | Item1[]),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    '*/items',
    async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {
      return HttpResponse.json(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getGetItemsResponseMock(),
        { status: 200 },
      );
    },
    options,
  );
};

export const getGetItemsWithMultiplePropsMockHandler = (
  overrideResponse?:
    | Item3[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<Item3[]> | Item3[]),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    '*/items-with-multiple-props',
    async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {
      return HttpResponse.json(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getGetItemsWithMultiplePropsResponseMock(),
        { status: 200 },
      );
    },
    options,
  );
};

export const getGetNestedItemsMockHandler = (
  overrideResponse?:
    | NestedItem[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<NestedItem[]> | NestedItem[]),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    '*/nested-items',
    async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {
      return HttpResponse.json(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getGetNestedItemsResponseMock(),
        { status: 200 },
      );
    },
    options,
  );
};

export const getGetMixedEnumItemsMockHandler = (
  overrideResponse?:
    | MixedEnumItem[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<MixedEnumItem[]> | MixedEnumItem[]),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    '*/mixed-enum-items',
    async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {
      return HttpResponse.json(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getGetMixedEnumItemsResponseMock(),
        { status: 200 },
      );
    },
    options,
  );
};

export const getGetMixedTypeEnumsMockHandler = (
  overrideResponse?:
    | MixedTypeEnums[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<MixedTypeEnums[]> | MixedTypeEnums[]),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    '*/mixed-type-enums',
    async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {
      return HttpResponse.json(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getGetMixedTypeEnumsResponseMock(),
        { status: 200 },
      );
    },
    options,
  );
};
export const getNullableOneOfEnumsMock = () => [
  getGetItemsMockHandler(),
  getGetItemsWithMultiplePropsMockHandler(),
  getGetNestedItemsMockHandler(),
  getGetMixedEnumItemsMockHandler(),
  getGetMixedTypeEnumsMockHandler(),
];
