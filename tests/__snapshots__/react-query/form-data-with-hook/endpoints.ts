/**
 * Generated by orval v8.4.2 ðŸº
 * Do not edit manually.
 * Swagger Petstore
 * OpenAPI spec version: 1.0.0
 */
import { useMutation } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult,
} from '@tanstack/react-query';

import { useCallback } from 'react';

import type { Error } from './model';

import { faker } from '@faker-js/faker';

import { HttpResponse, http } from 'msw';
import type { RequestHandlerOptions } from 'msw';

import type { Pet, PetBase, PetExtended } from './model';

import { useCustomInstance } from '../../../mutators/use-custom-instance';
/**
 * @summary Create a pet
 */
export const useCreatePetsHook = () => {
  const createPets = useCustomInstance<Pet>();

  return useCallback(
    (pet: Pet, signal?: AbortSignal) => {
      const formData = new FormData();
      const petPetBase = pet as PetBase;
      if (petPetBase.name !== undefined) {
        formData.append(`name`, petPetBase.name);
      }
      if (petPetBase.tag !== undefined) {
        formData.append(`tag`, petPetBase.tag);
      }

      const petPetExtended = pet as PetExtended;
      if (petPetExtended.id !== undefined) {
        formData.append(`id`, petPetExtended.id.toString());
      }
      if (petPetExtended.name !== undefined) {
        formData.append(`name`, petPetExtended.name);
      }
      if (petPetExtended.tag !== undefined) {
        formData.append(`tag`, petPetExtended.tag);
      }
      if (pet['@id'] !== undefined) {
        formData.append(`@id`, pet['@id']);
      }
      if (pet.email !== undefined) {
        formData.append(`email`, pet.email);
      }
      if (pet.callingCode !== undefined) {
        formData.append(`callingCode`, pet.callingCode);
      }
      if (pet.country !== undefined) {
        formData.append(`country`, pet.country);
      }

      return createPets({
        url: `/pets`,
        method: 'POST',
        data: formData,
        signal,
      });
    },
    [createPets],
  );
};

export const useCreatePetsMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useCreatePetsHook>>>,
    TError,
    { data: Pet },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<ReturnType<typeof useCreatePetsHook>>>,
  TError,
  { data: Pet },
  TContext
> => {
  const mutationKey = ['createPets'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const createPets = useCreatePetsHook();

  const mutationFn: MutationFunction<
    Awaited<ReturnType<ReturnType<typeof useCreatePetsHook>>>,
    { data: Pet }
  > = (props) => {
    const { data } = props ?? {};

    return createPets(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePetsMutationResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useCreatePetsHook>>>
>;
export type CreatePetsMutationBody = Pet;
export type CreatePetsMutationError = Error;

/**
 * @summary Create a pet
 */
export const useCreatePets = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<ReturnType<typeof useCreatePetsHook>>>,
      TError,
      { data: Pet },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<ReturnType<typeof useCreatePetsHook>>>,
  TError,
  { data: Pet },
  TContext
> => {
  return useMutation(useCreatePetsMutationOptions(options), queryClient);
};

export const getCreatePetsResponsePetBaseMock = (
  overrideResponse: Partial<PetBase> = {},
): PetBase => ({
  ...{
    name: faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      undefined,
    ]),
    tag: faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      undefined,
    ]),
  },
  ...overrideResponse,
});

export const getCreatePetsResponsePetExtendedMock = (
  overrideResponse: Partial<PetExtended> = {},
): PetExtended => ({
  ...{
    id: faker.helpers.arrayElement([faker.number.int(), undefined]),
    name: faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      undefined,
    ]),
    tag: faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      undefined,
    ]),
  },
  ...overrideResponse,
});

export const getCreatePetsResponseMock = (): Pet => ({
  ...faker.helpers.arrayElement([
    { ...getCreatePetsResponsePetBaseMock() },
    { ...getCreatePetsResponsePetExtendedMock() },
  ]),
  '@id': faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  email: faker.helpers.arrayElement([faker.internet.email(), undefined]),
  callingCode: faker.helpers.arrayElement([
    faker.helpers.arrayElement(['+33', '+420', '+33'] as const),
    undefined,
  ]),
  country: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      "People's Republic of China",
      'Uruguay',
    ] as const),
    undefined,
  ]),
});

export const getCreatePetsMockHandler = (
  overrideResponse?:
    | Pet
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<Pet> | Pet),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    '*/pets',
    async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {
      return HttpResponse.json(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getCreatePetsResponseMock(),
        { status: 200 },
      );
    },
    options,
  );
};
export const getSwaggerPetstoreMock = () => [getCreatePetsMockHandler()];
