/**
 * Generated by orval v8.4.1 ðŸº
 * Do not edit manually.
 * Swagger Petstore
 * OpenAPI spec version: 1.0.0
 */
import type { Key } from 'swr';

import useSWRMutation from 'swr/mutation';
import type { SWRMutationConfiguration } from 'swr/mutation';

import type { Cookie, OptionalPetBodyBody, RequiredPetBodyBody } from './model';

import { HttpResponse, http } from 'msw';
import type { RequestHandlerOptions } from 'msw';

export type createPetsResponse204 = {
  data: void;
  status: 204;
};

export type createPetsResponseSuccess = createPetsResponse204 & {
  headers: Headers;
};
export type createPetsResponse = createPetsResponseSuccess;

export const getCreatePetsUrl = () => {
  return `/pets`;
};

export const createPets = async (
  requiredPetBodyBody: RequiredPetBodyBody,
  options?: RequestInit,
): Promise<createPetsResponse> => {
  const res = await fetch(getCreatePetsUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(requiredPetBodyBody),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createPetsResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as createPetsResponse;
};

export const getCreatePetsMutationFetcher = (options?: RequestInit) => {
  return (_: Key, { arg }: { arg: RequiredPetBodyBody }) => {
    return createPets(arg, options);
  };
};
export const getCreatePetsMutationKey = () => [`/pets`] as const;

export type CreatePetsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPets>>
>;

export const useCreatePets = <TError = Promise<unknown>>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof createPets>>,
    TError,
    Key,
    RequiredPetBodyBody,
    Awaited<ReturnType<typeof createPets>>
  > & { swrKey?: string };
  fetch?: RequestInit;
}) => {
  const { swr: swrOptions, fetch: fetchOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getCreatePetsMutationKey();
  const swrFn = getCreatePetsMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

export type updatePetsResponse204 = {
  data: void;
  status: 204;
};

export type updatePetsResponseSuccess = updatePetsResponse204 & {
  headers: Headers;
};
export type updatePetsResponse = updatePetsResponseSuccess;

export const getUpdatePetsUrl = () => {
  return `/pets`;
};

export const updatePets = async (
  optionalPetBodyBody?: OptionalPetBodyBody,
  options?: RequestInit,
): Promise<updatePetsResponse> => {
  const res = await fetch(getUpdatePetsUrl(), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(optionalPetBodyBody),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: updatePetsResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as updatePetsResponse;
};

export const getUpdatePetsMutationFetcher = (options?: RequestInit) => {
  return (_: Key, { arg }: { arg: OptionalPetBodyBody }) => {
    return updatePets(arg, options);
  };
};
export const getUpdatePetsMutationKey = () => [`/pets`] as const;

export type UpdatePetsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePets>>
>;

export const useUpdatePets = <TError = Promise<unknown>>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof updatePets>>,
    TError,
    Key,
    OptionalPetBodyBody,
    Awaited<ReturnType<typeof updatePets>>
  > & { swrKey?: string };
  fetch?: RequestInit;
}) => {
  const { swr: swrOptions, fetch: fetchOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getUpdatePetsMutationKey();
  const swrFn = getUpdatePetsMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

export type createCookiesResponse204 = {
  data: void;
  status: 204;
};

export type createCookiesResponseSuccess = createCookiesResponse204 & {
  headers: Headers;
};
export type createCookiesResponse = createCookiesResponseSuccess;

export const getCreateCookiesUrl = () => {
  return `/cookies`;
};

export const createCookies = async (
  cookie: Cookie,
  options?: RequestInit,
): Promise<createCookiesResponse> => {
  const res = await fetch(getCreateCookiesUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(cookie),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createCookiesResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as createCookiesResponse;
};

export const getCreateCookiesMutationFetcher = (options?: RequestInit) => {
  return (_: Key, { arg }: { arg: Cookie }) => {
    return createCookies(arg, options);
  };
};
export const getCreateCookiesMutationKey = () => [`/cookies`] as const;

export type CreateCookiesMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCookies>>
>;

export const useCreateCookies = <TError = Promise<unknown>>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof createCookies>>,
    TError,
    Key,
    Cookie,
    Awaited<ReturnType<typeof createCookies>>
  > & { swrKey?: string };
  fetch?: RequestInit;
}) => {
  const { swr: swrOptions, fetch: fetchOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getCreateCookiesMutationKey();
  const swrFn = getCreateCookiesMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

export type updateCookiesResponse204 = {
  data: void;
  status: 204;
};

export type updateCookiesResponseSuccess = updateCookiesResponse204 & {
  headers: Headers;
};
export type updateCookiesResponse = updateCookiesResponseSuccess;

export const getUpdateCookiesUrl = () => {
  return `/cookies`;
};

export const updateCookies = async (
  cookie?: Cookie,
  options?: RequestInit,
): Promise<updateCookiesResponse> => {
  const res = await fetch(getUpdateCookiesUrl(), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(cookie),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: updateCookiesResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as updateCookiesResponse;
};

export const getUpdateCookiesMutationFetcher = (options?: RequestInit) => {
  return (_: Key, { arg }: { arg: Cookie }) => {
    return updateCookies(arg, options);
  };
};
export const getUpdateCookiesMutationKey = () => [`/cookies`] as const;

export type UpdateCookiesMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCookies>>
>;

export const useUpdateCookies = <TError = Promise<unknown>>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof updateCookies>>,
    TError,
    Key,
    Cookie,
    Awaited<ReturnType<typeof updateCookies>>
  > & { swrKey?: string };
  fetch?: RequestInit;
}) => {
  const { swr: swrOptions, fetch: fetchOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getUpdateCookiesMutationKey();
  const swrFn = getUpdateCookiesMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

export const getCreatePetsMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<void> | void),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    '*/pets',
    async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {
      if (typeof overrideResponse === 'function') {
        await overrideResponse(info);
      }

      return new HttpResponse(null, { status: 204 });
    },
    options,
  );
};

export const getUpdatePetsMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<void> | void),
  options?: RequestHandlerOptions,
) => {
  return http.put(
    '*/pets',
    async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {
      if (typeof overrideResponse === 'function') {
        await overrideResponse(info);
      }

      return new HttpResponse(null, { status: 204 });
    },
    options,
  );
};

export const getCreateCookiesMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<void> | void),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    '*/cookies',
    async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {
      if (typeof overrideResponse === 'function') {
        await overrideResponse(info);
      }

      return new HttpResponse(null, { status: 204 });
    },
    options,
  );
};

export const getUpdateCookiesMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<void> | void),
  options?: RequestHandlerOptions,
) => {
  return http.put(
    '*/cookies',
    async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {
      if (typeof overrideResponse === 'function') {
        await overrideResponse(info);
      }

      return new HttpResponse(null, { status: 204 });
    },
    options,
  );
};
export const getSwaggerPetstoreMock = () => [
  getCreatePetsMockHandler(),
  getUpdatePetsMockHandler(),
  getCreateCookiesMockHandler(),
  getUpdateCookiesMockHandler(),
];
