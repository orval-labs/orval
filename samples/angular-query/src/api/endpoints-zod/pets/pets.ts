/**
 * Generated by orval v8.3.0 üç∫
 * Do not edit manually.
 * Swagger Petstore
 * OpenAPI spec version: 1.0.0
 */
import {
  HttpClient,
  HttpParams
} from '@angular/common/http';

import {
  inject
} from '@angular/core';

import {
  injectMutation,
  injectQuery
} from '@tanstack/angular-query-experimental';
import type {
  CreateMutationOptions,
  CreateMutationResult,
  CreateQueryOptions,
  CreateQueryResult,
  MutationFunction,
  QueryFunction
} from '@tanstack/angular-query-experimental';

import {
  fromEvent,
  lastValueFrom
} from 'rxjs';

import {
  map,
  takeUntil
} from 'rxjs/operators';

import {
  Pet,
  PetWithTag,
  Pets
} from '../../model-zod/index.zod';
import type {
  CreatePetsBody,
  CreatePetsParams,
  Error,
  ListPetsParams
} from '../../model-zod/index.zod';




function filterParams(
  params: Record<string, unknown>,
  requiredNullableKeys: Set<string> = new Set(),
): Record<string, string | number | boolean | Array<string | number | boolean>> {
  const filteredParams: Record<string, string | number | boolean | null | Array<string | number | boolean>> = {};
  for (const [key, value] of Object.entries(params)) {
    if (Array.isArray(value)) {
      const filtered = value.filter(
        (item) =>
          item != null &&
          (typeof item === 'string' ||
            typeof item === 'number' ||
            typeof item === 'boolean'),
      ) as Array<string | number | boolean>;
      if (filtered.length) {
        filteredParams[key] = filtered;
      }
    } else if (value === null && requiredNullableKeys.has(key)) {
      filteredParams[key] = value;
    } else if (
      value != null &&
      (typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean')
    ) {
      filteredParams[key] = value as string | number | boolean;
    }
  }
  return filteredParams as Record<string, string | number | boolean | Array<string | number | boolean>>;
}
/**
 * @summary List all pets
 */
export const listPets = (
    http: HttpClient,
    params: ListPetsParams, options?: { signal?: AbortSignal | null }
  ): Promise<Pets> => {
    
    const httpParams = params ? new HttpParams({ fromObject: filterParams(params, new Set<string>([])) }) : undefined;
    const url = `/pets`;
    const request$ = http.get<Pets>(url, { params: httpParams }).pipe(map(data => Pets.parse(data)));
    if (options?.signal) {
      return lastValueFrom(request$.pipe(takeUntil(fromEvent(options.signal, 'abort'))));
    }
    return lastValueFrom(request$);
  }




export const getListPetsQueryKey = (params?: ListPetsParams,) => {
    return [
    `/pets`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListPetsQueryOptions = <TData = Awaited<ReturnType<typeof listPets>>, TError = Error>(http: HttpClient, params: ListPetsParams, options?: { query?:Partial<CreateQueryOptions<Awaited<ReturnType<typeof listPets>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPetsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPets>>> = ({ signal }) => listPets(http, params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as CreateQueryOptions<Awaited<ReturnType<typeof listPets>>, TError, TData> 
}

export type ListPetsQueryResult = NonNullable<Awaited<ReturnType<typeof listPets>>>
export type ListPetsQueryError = Error


/**
 * @summary List all pets
 */

export function injectListPets<TData = Awaited<ReturnType<typeof listPets>>, TError = Error>(
 params: ListPetsParams | (() => ListPetsParams), options?: { query?:Partial<CreateQueryOptions<Awaited<ReturnType<typeof listPets>>, TError, TData>>, fetch?: RequestInit} | (() => { query?:Partial<CreateQueryOptions<Awaited<ReturnType<typeof listPets>>, TError, TData>>, fetch?: RequestInit})
  
 ): CreateQueryResult<TData, TError> {

  const http = inject(HttpClient);

  const query = injectQuery(() => {
    // Resolve params if getter function (for signal reactivity)
    const _params = typeof params === 'function' ? params() : params;
    // Resolve options if getter function (for signal reactivity)
    const _options = typeof options === 'function' ? options() : options;
    return getListPetsQueryOptions(http, _params, _options);
  }) as CreateQueryResult<TData, TError>;

  return query;
}




/**
 * @summary Create a pet
 */
export const createPets = (
    http: HttpClient,
    createPetsBody: CreatePetsBody,
    params: CreatePetsParams, options?: { signal?: AbortSignal | null }
  ): Promise<Pet> => {
    
    const httpParams = params ? new HttpParams({ fromObject: filterParams(params, new Set<string>([])) }) : undefined;
    const url = `/pets`;
    const request$ = http.post<Pet>(url, createPetsBody, { params: httpParams }).pipe(map(data => Pet.parse(data)));
    if (options?.signal) {
      return lastValueFrom(request$.pipe(takeUntil(fromEvent(options.signal, 'abort'))));
    }
    return lastValueFrom(request$);
  }



export const getCreatePetsMutationOptions = <TError = Error,
    TContext = unknown>(http: HttpClient, options?: { mutation?:CreateMutationOptions<Awaited<ReturnType<typeof createPets>>, TError,{data: CreatePetsBody;params: CreatePetsParams}, TContext>, fetch?: RequestInit}
): CreateMutationOptions<Awaited<ReturnType<typeof createPets>>, TError,{data: CreatePetsBody;params: CreatePetsParams}, TContext> => {

const mutationKey = ['createPets'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPets>>, {data: CreatePetsBody;params: CreatePetsParams}> = (props) => {
          const {data,params} = props ?? {};

          return  createPets(http, data,params,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePetsMutationResult = NonNullable<Awaited<ReturnType<typeof createPets>>>
    export type CreatePetsMutationBody = CreatePetsBody
    export type CreatePetsMutationError = Error

    /**
 * @summary Create a pet
 */
export const injectCreatePets = <TError = Error,
    TContext = unknown>(options?: { mutation?:CreateMutationOptions<Awaited<ReturnType<typeof createPets>>, TError,{data: CreatePetsBody;params: CreatePetsParams}, TContext>, fetch?: RequestInit}
 ): CreateMutationResult<
        Awaited<ReturnType<typeof createPets>>,
        TError,
        {data: CreatePetsBody;params: CreatePetsParams},
        TContext
      > => {
      const http = inject(HttpClient);
      const createPetsMutationOptions = getCreatePetsMutationOptions(http, options);

      return injectMutation(() => createPetsMutationOptions);
    }
    /**
 * @summary Info for a specific pet
 */
export const showPetById = (
    http: HttpClient,
    petId: string, options?: { signal?: AbortSignal | null }
  ): Promise<Pet> => {
    
    const url = `/pets/${petId}`;
    const request$ = http.get<Pet>(url).pipe(map(data => Pet.parse(data)));
    if (options?.signal) {
      return lastValueFrom(request$.pipe(takeUntil(fromEvent(options.signal, 'abort'))));
    }
    return lastValueFrom(request$);
  }




export const getShowPetByIdQueryKey = (petId: string,) => {
    return [
    `/pets/${petId}`
    ] as const;
    }

    
export const getShowPetByIdQueryOptions = <TData = Awaited<ReturnType<typeof showPetById>>, TError = Error>(http: HttpClient, petId: string, options?: { query?:Partial<CreateQueryOptions<Awaited<ReturnType<typeof showPetById>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getShowPetByIdQueryKey(petId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof showPetById>>> = ({ signal }) => showPetById(http, petId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(petId), ...queryOptions} as CreateQueryOptions<Awaited<ReturnType<typeof showPetById>>, TError, TData> 
}

export type ShowPetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof showPetById>>>
export type ShowPetByIdQueryError = Error


/**
 * @summary Info for a specific pet
 */

export function injectShowPetById<TData = Awaited<ReturnType<typeof showPetById>>, TError = Error>(
 petId: string | (() => string), options?: { query?:Partial<CreateQueryOptions<Awaited<ReturnType<typeof showPetById>>, TError, TData>>, fetch?: RequestInit} | (() => { query?:Partial<CreateQueryOptions<Awaited<ReturnType<typeof showPetById>>, TError, TData>>, fetch?: RequestInit})
  
 ): CreateQueryResult<TData, TError> {

  const http = inject(HttpClient);

  const query = injectQuery(() => {
    // Resolve params if getter function (for signal reactivity)
    const _petId = typeof petId === 'function' ? petId() : petId;
    // Resolve options if getter function (for signal reactivity)
    const _options = typeof options === 'function' ? options() : options;
    return getShowPetByIdQueryOptions(http, _petId, _options);
  }) as CreateQueryResult<TData, TError>;

  return query;
}




/**
 * @summary Deletes a specific pet
 */
export const deletePetById = (
    http: HttpClient,
    petId: string, options?: { signal?: AbortSignal | null }
  ): Promise<void> => {
    
    const url = `/pets/${petId}`;
    const request$ = http.delete<void>(url);
    if (options?.signal) {
      return lastValueFrom(request$.pipe(takeUntil(fromEvent(options.signal, 'abort'))));
    }
    return lastValueFrom(request$);
  }



export const getDeletePetByIdMutationOptions = <TError = Error,
    TContext = unknown>(http: HttpClient, options?: { mutation?:CreateMutationOptions<Awaited<ReturnType<typeof deletePetById>>, TError,{petId: string}, TContext>, fetch?: RequestInit}
): CreateMutationOptions<Awaited<ReturnType<typeof deletePetById>>, TError,{petId: string}, TContext> => {

const mutationKey = ['deletePetById'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePetById>>, {petId: string}> = (props) => {
          const {petId} = props ?? {};

          return  deletePetById(http, petId,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePetByIdMutationResult = NonNullable<Awaited<ReturnType<typeof deletePetById>>>
    
    export type DeletePetByIdMutationError = Error

    /**
 * @summary Deletes a specific pet
 */
export const injectDeletePetById = <TError = Error,
    TContext = unknown>(options?: { mutation?:CreateMutationOptions<Awaited<ReturnType<typeof deletePetById>>, TError,{petId: string}, TContext>, fetch?: RequestInit}
 ): CreateMutationResult<
        Awaited<ReturnType<typeof deletePetById>>,
        TError,
        {petId: string},
        TContext
      > => {
      const http = inject(HttpClient);
      const deletePetByIdMutationOptions = getDeletePetByIdMutationOptions(http, options);

      return injectMutation(() => deletePetByIdMutationOptions);
    }
    /**
 * @summary combinate nullable and $ref
 */
export const showPetWithOwner = (
    http: HttpClient,
    petId: string, options?: { signal?: AbortSignal | null }
  ): Promise<PetWithTag> => {
    
    const url = `/pets/${petId}/owner`;
    const request$ = http.get<PetWithTag>(url).pipe(map(data => PetWithTag.parse(data)));
    if (options?.signal) {
      return lastValueFrom(request$.pipe(takeUntil(fromEvent(options.signal, 'abort'))));
    }
    return lastValueFrom(request$);
  }




export const getShowPetWithOwnerQueryKey = (petId: string,) => {
    return [
    `/pets/${petId}/owner`
    ] as const;
    }

    
export const getShowPetWithOwnerQueryOptions = <TData = Awaited<ReturnType<typeof showPetWithOwner>>, TError = Error>(http: HttpClient, petId: string, options?: { query?:Partial<CreateQueryOptions<Awaited<ReturnType<typeof showPetWithOwner>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getShowPetWithOwnerQueryKey(petId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof showPetWithOwner>>> = ({ signal }) => showPetWithOwner(http, petId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(petId), ...queryOptions} as CreateQueryOptions<Awaited<ReturnType<typeof showPetWithOwner>>, TError, TData> 
}

export type ShowPetWithOwnerQueryResult = NonNullable<Awaited<ReturnType<typeof showPetWithOwner>>>
export type ShowPetWithOwnerQueryError = Error


/**
 * @summary combinate nullable and $ref
 */

export function injectShowPetWithOwner<TData = Awaited<ReturnType<typeof showPetWithOwner>>, TError = Error>(
 petId: string | (() => string), options?: { query?:Partial<CreateQueryOptions<Awaited<ReturnType<typeof showPetWithOwner>>, TError, TData>>, fetch?: RequestInit} | (() => { query?:Partial<CreateQueryOptions<Awaited<ReturnType<typeof showPetWithOwner>>, TError, TData>>, fetch?: RequestInit})
  
 ): CreateQueryResult<TData, TError> {

  const http = inject(HttpClient);

  const query = injectQuery(() => {
    // Resolve params if getter function (for signal reactivity)
    const _petId = typeof petId === 'function' ? petId() : petId;
    // Resolve options if getter function (for signal reactivity)
    const _options = typeof options === 'function' ? options() : options;
    return getShowPetWithOwnerQueryOptions(http, _petId, _options);
  }) as CreateQueryResult<TData, TError>;

  return query;
}




