/**
 * Generated by orval v8.3.0 üç∫
 * Do not edit manually.
 * Swagger Petstore
 * OpenAPI spec version: 1.0.0
 */
import {
  HttpClient
} from '@angular/common/http';

import {
  inject
} from '@angular/core';

import {
  injectQuery
} from '@tanstack/angular-query-experimental';
import type {
  CreateQueryOptions,
  CreateQueryResult,
  QueryFunction
} from '@tanstack/angular-query-experimental';

import {
  fromEvent,
  lastValueFrom
} from 'rxjs';

import {
  takeUntil
} from 'rxjs/operators';

import type {
  Error
} from '../../model-zod/index.zod';




function filterParams(
  params: Record<string, unknown>,
  requiredNullableKeys: Set<string> = new Set(),
): Record<string, string | number | boolean | Array<string | number | boolean>> {
  const filteredParams: Record<string, string | number | boolean | null | Array<string | number | boolean>> = {};
  for (const [key, value] of Object.entries(params)) {
    if (Array.isArray(value)) {
      const filtered = value.filter(
        (item) =>
          item != null &&
          (typeof item === 'string' ||
            typeof item === 'number' ||
            typeof item === 'boolean'),
      ) as Array<string | number | boolean>;
      if (filtered.length) {
        filteredParams[key] = filtered;
      }
    } else if (value === null && requiredNullableKeys.has(key)) {
      filteredParams[key] = value;
    } else if (
      value != null &&
      (typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean')
    ) {
      filteredParams[key] = value as string | number | boolean;
    }
  }
  return filteredParams as Record<string, string | number | boolean | Array<string | number | boolean>>;
}
/**
 * @summary health check
 */
export const healthCheck = (
    http: HttpClient,
    options?: { signal?: AbortSignal | null }
  ): Promise<string> => {
    
    const url = `/health`;
    const request$ = http.get(url, { responseType: 'text' });
    if (options?.signal) {
      return lastValueFrom(request$.pipe(takeUntil(fromEvent(options.signal, 'abort'))));
    }
    return lastValueFrom(request$);
  }




export const getHealthCheckQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof healthCheck>>, TError = Error>(http: HttpClient,  options?: { query?:Partial<CreateQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck(http, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as CreateQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> 
}

export type HealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckQueryError = Error


/**
 * @summary health check
 */

export function injectHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = Error>(
  options?: { query?:Partial<CreateQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, fetch?: RequestInit} | (() => { query?:Partial<CreateQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, fetch?: RequestInit})
  
 ): CreateQueryResult<TData, TError> {

  const http = inject(HttpClient);

  const query = injectQuery(() => {
    // Resolve options if getter function (for signal reactivity)
    const _options = typeof options === 'function' ? options() : options;
    return getHealthCheckQueryOptions(http, _options);
  }) as CreateQueryResult<TData, TError>;

  return query;
}




